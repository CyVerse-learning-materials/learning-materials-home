# Create Your Own Apps in the Discovery Environment

The CyVerse Discovery Environment (DE) has hundreds of apps available but if you ever discover that you can't find the
app you're looking for, you can add your own apps into the DE.

Suppose for an admittedly contrived example that you want to use the DE to generate pass phrases. You've got this great
little app that you've written that takes a few command-line arguments and creates one ore more phass phrases using the
[Diceware][1] method. You'd love to add it to the DE in order to generate pass phrases for yourself, and it would be a
nice bonus if you could share it with other users so that they can do the same thing.

If you'd like to follow along, you can obtain the source code from this [GitHub repository][8].

!!! Note: actually using the DE to generate pass phrases probably isn't a great idea, but it's a fun example.

## Dockerfile

The first step is to get the tool into a Docker image. The DE uses Docker container images for all of its tools because
they provide the perfect isolation chamber for both the software itself and any dependencies that it may require,
allowing the DE to run nearly any tool that will run on a Linux computer without having to worry about managing possibly
conflicting dependency chains for different pieces of software.

The Diceware app is going to use a two-step method to create the container. The first step will compile the software
generating a file that can be executed quickly. The second step will start with a second base container image and copy
the compiled software and a little wrapper script to that second container image. The final container will be based on
the container created by the second step.

### Compiling the Software

The first thing we need to compile the software is a Docker container that has all of the developer tools that we
need. The `diceware` application is written in [Clojure][3], and it uses a build tool called [Leiningen][4], so we need
a container that has both Clojure and Leiningen installed. Fortunately for us, an image with both installed is already
available on [DockerHub][5]. To make use of that image, all we have to do is add this line to the top of the Dockerfile:

``` dockerfile
FROM clojure
```

This tells Docker to create a container using that image, pulling it from DockerHub if necessary. The next step is to
actually copy the code into the container and run the build command. These three lines accomplish that:

``` dockerfile
WORKDIR /opt/diceware
COPY . .
RUN lein do clean, uberjar
```

The `WORKDIR` command tells Docker which directory should be used as the working directory during the image creation
process. If the directory doesn't exist in the original image, Docker will automatically create it. The `COPY` command
copies files from the location where the Docker image is being built into the working directory in the container. All
files are copied by this command. Please see the [Dockerfile Reference Documentation][6] for more details. The `RUN`
command runs a command inside the container. This is the command that actually builds the software.

### Placing the Software in a Container Image

Using a two stage build process allows us to create a container image without software that we don't need. In this case,
all we need to run the compiled software is Java, so there's no need to have Clojure or Leiningen installed. There are
several Docker images for OpenJDK available. In this case, we're going to use [eclipse-temurin][7].

``` dockerfile
FROM eclipse-temurin
```

The next step is to copy the JAR file and the wrapper script over from the build container. The following commands will
do that:

``` dockerfile
COPY --from=0 /opt/diceware/target/uberjar/diceware-standalone.jar /opt/diceware/
COPY diceware /usr/bin/
```

These two `COPY` commands deserve a little bit of explanation. The first one copies the JAR file that was generated in
the build container into the `/opt/diceware` directory in the destination container. The `--from=0` option tells Docker
to copy the file from the first container generated by the Dockerfile rather than from the host computer. The second
command copies the `diceware` wrapper script from the host computer into the `/usr/bin` directory in teh destination
container.

Finally, we need to tell Docker which command to run by default when a new container is launched using the image that
we're creating. This line does that:

``` dockerfile
ENTRYPOINT ["diceware"]
```

Note that the format for argument to the `ENTRYPOINT` command is an array of command-line arguments. In this case,
there's only one command-line argument, which is the name of the command itself. Note that I don't have to specify a
full path to the executable because `diceware` is in `/usr/bin`, which is on the executable search path by default. The
complete Dockerfile looks like this:

``` dockerfile
FROM clojure

WORKDIR /opt/diceware
COPY . .
RUN lein do clean, uberjar

FROM eclipse-temurin

COPY --from=0 /opt/diceware/target/uberjar/diceware-standalone.jar /opt/diceware/
COPY diceware /usr/bin/

ENTRYPOINT ["diceware"]
```

## Building the Docker Image

The DE needs to be able to access the container image that we're creating before using it in an app, so our next step is
to build the container image and push it to a public Docker registry. For development testing, it's perfectly reasonable
to publish the image on DockerHub.

Building the image itseif is relatively straightforward. All you have to do is run a command that looks something like
this in the directory where you have both the source code and the Dockerfile:

```
$ docker build --rm -t slr71/diceware .
```

I say that the command has to look something like this becuase the Docker registry that I'm using is specific to
me. Someone whose DockerHub username is `awesomeuser` might run this command instead:

```
$ docker build --rm -t awesomeuser/diceware .
```

After building the container, it's a good idea to verify that it built correctly. You can do that by running the
container:

```
$ docker run --rm -it slr71/diceware --help
Generates a Diceware password:

Options:
  -w, --num-words INTEGER      4                                                            The number of words to include in each generated password.
  -n, --num-passwords INTEGER  1                                                            The number of passwords to generate.
  -s, --separator STRING       *                                                            The separator to insert between words.
  -u, --word-list-url STRING   https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt  The URL to the word list.
  -h, --help
```

The help message seems to be working. Let's try to generate a password and see what happens:

```
$ docker run --rm -it slr71/diceware
linked*wrongly*juvenile*amiss
```

Now that we've built the image and tried it out, the next step is to push the image to the Docker registry so that it
will be accessible to the DE:

```
$ docker push slr71/diceware
Using default tag: latest
The push refers to repository [docker.io/slr71/diceware]
aee1a4bb6959: Pushed
c2ee644a89a3: Pushed
11a56f1e56dc: Mounted from library/eclipse-temurin
c73db2f9a22a: Mounted from library/eclipse-temurin
2ab7b3a14ab3: Mounted from library/eclipse-temurin
d139aec00a98: Mounted from library/eclipse-temurin
375990b2a90a: Mounted from library/eclipse-temurin
latest: digest: sha256:39aa70a23f82743d37b72a629e2957023d8b2852696f73cadacc917dda109c8d size: 1787
```

## Defining the Tool in the DE

Before the DE can use a container image in an app, it has to know some information about the container image. This is
done by creating a tool definition in the DE. To start this process, first click the hamburger menu in the upper
left-hand corner of the Discovery environment:

![Hamburger Menu](../assets/de/hamburger-menu.png)



## Defining the App in the DE

## Running the App in the DE

## Publishing the App in the DE

[1]: https://diceware.dmuth.org/
[2]: https://docs.docker.com/
[3]: https://clojure.org/
[4]: https://leiningen.org/
[5]: https://hub.docker.com/_/clojure
[6]: https://docs.docker.com/reference/dockerfile/#copy
[7]: https://hub.docker.com/_/eclipse-temurin
[8]: https://github.com/slr71/diceware
